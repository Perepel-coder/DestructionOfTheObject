#include "pch.h"
#include "Main.h"
// Теперь нам нужно написать функцию, получающую ID кликнутого обьекта:
int RetrieveObjectID(int x, int y) {
	int objectsFound = 0;   // Общее количество кликнутых обьектов 
	int viewportCoords[4] = { 0 };    // Массив для хранения экранных координат
	// Переменная для хранения ID обьектов, на которые мы кликнули. 
	// Мы делаем массив в 32 элемента, т.к. OpenGL также сохраняет другую 
	// информацию, которая нам сейчас не нужна. Для каждого обьекта нужно 4 слота.
	unsigned int selectBuffer[32] = { 0 };
	// glSelectBuffer регистрирует массив как буфер выбора обьектов. 
	// Первый параметр — размер массива. 
	// Второй — сам массив для хранения информации.
	glSelectBuffer(32, selectBuffer);	// Регистрируем буфер для хранения выбранных обьектов
	// Эта функция возвращает информацию о многих вещах в OpenGL. 
	// Мы передаём GL_VIEWPOR, чтобы получить координаты экрана.
	// Функция сохранит их в переданном вторым параметром массиве
	// в виде top,left,bottom,right.
	glGetIntegerv(GL_VIEWPORT, viewportCoords); // Получаем текущие координаты экрана
	// Теперь выходим из матрицы GL_MODELVIEW и переходим в матрицу GL_PROJECTION.
	// Это даёт возможность использовать X и Y координаты вместо 3D.
	glMatrixMode(GL_PROJECTION);    // Переходим в матрицу проекции
	glPushMatrix();         // Переходим в новые экранные координаты
	// Эта функция делает так, что фреймбуфер не изменяется при рендере в него, 
	// вместо этого происходит запись имён (ID) примитивов, которые были бы
	// отрисованы при режиме GL_RENDER. Информация помещается в selectBuffer.
	glRenderMode(GL_SELECT);    // Позволяет рендерить обьекты без изменения фреймбуфера
	glLoadIdentity();       // Сбросим матрицу проекции
	// gluPickMatrix позволяет создавать матрицу проекции около нашего курсора. 
	// Проще говоря, рендерится только область, которую мы укажем (вокруг курсора).
	// Если обьект рендерится в этой области, его ID сохраняется (Вот он, смысл всей функции).
	// Первые 2 параметра — X и Y координаты начала, следующие 2 — ширина и высота области
	// отрисовки. Последний параметр — экранные координаты. Заметьте, мы вычитаем 'y' из
	// НИЖНЕЙ экранной координаты. Мы сделали это, чтобы перевернуть Y координаты.
	// В 3д-пространстве нулевые y-координаты начинаются внизу, а в экранных координатах
	// 0 по y находится вверху. Также передаём регион 2 на 2 пиксела для поиска в нём обьекта.
	// Это может быть изменено
	gluPickMatrix(x, viewportCoords[3] - y, 2, 2, viewportCoords);
	// Далее просто вызываем нашу нормальную функцию gluPerspective, 
	// точно так же, как делали при инициализации.
	gluPerspective(45.0f, (GLfloat)camera_width / (GLfloat)camera_height, 10, 10000.0f);
	glMatrixMode(GL_MODELVIEW); // Возвращаемся в матрицу GL_MODELVIEW
	DrawGLScene();	// Теперь рендерим выбранную зону для выбора обьекта
	// Если мы вернёмся в нормальный режим рендеринга из режима выбора, 
	// glRenderMode возвратит число обьектов, найденных в указанном регионе 
	// (в gluPickMatrix ()).
	objectsFound = glRenderMode(GL_RENDER); // Вернемся в режим отрисовки и получим число обьектов
	glMatrixMode(GL_PROJECTION);    // Вернемся в привычную матрицу проекции
	glPopMatrix();              // Выходим из матрицы
	glMatrixMode(GL_MODELVIEW);     // Вернемся в матрицу GL_MODELVIEW
	// Теперь нам нужно выяснить ID выбранных обьектов.
	// Если они есть — objectsFound должно быть как минимум 1.
	if (objectsFound > 0) {
		// Если мы нашли более 1 обьекта, нужно проверить значения глубины всех
		// выбранных обьектов. Обьект с МЕНЬШИМ значением глубины — ближайший (логичненько)
		// Оно сохранено в буфере выбора (selectionBuffer). Для каждого обьекта в нем 4 значения.
		// Первое — "число имен в массиве имен на момент события, далее минимум и
		// максимум значений глубины для всех вершин, которые были выбраны при прошлом
		// событии, далее содержимое массива имен, нижнее имя — первое;
		// Единстве, что нам нужно — минимальное значение глубины (второе значение) и 
		// ID обьекта, переданного в glLoadName () (четвертое значение).
		// Итак, [0-3] — данные первого обьекта, [4-7] — второго, и т.д...
		// Итак, получим обьект с минимальной глубиной!
		// Поиск элемента с минимальной глбино (банальный поиск минимума в массиве)
		unsigned int lowestDepth = selectBuffer[1];
		int selectedObject = selectBuffer[3];
		for (int i = 1; i < objectsFound; i++) {
			// Проверяем, не ниже ли значение глубины текущего обьекта, чем предидущего.
			// Заметьте, мы умножаем i на 4 (4 значения на каждый обьект) и прибавляем 1 для глубины.
			if (selectBuffer[i * 3 + 1] < lowestDepth) {
				// Установим новое низшее значение 
				lowestDepth = selectBuffer[i * 4];
				// Установим текущий ID обьекта 
				selectedObject = selectBuffer[i *3 + 3];
			}
		}
		// Вернем выбранный обьект 
		return selectedObject;
	}
	// Если не щелкнули ни на 1 обьект, вернём 0 
	return 0;
}