#include "pch.h"
#include "Main.h"
// немного геометрии
VECTOR Cross(VECTOR v1, VECTOR v2) {	// ищет перпендикуляр	(векторное произведение)
	VECTOR v_normal;
	v_normal.x = (v1.y * v2.z) - (v1.z * v2.y);
	v_normal.y = (v1.z * v2.x) - (v1.x * v2.z);
	v_normal.z = (v1.x * v2.y) - (v1.y * v2.x);
	return v_normal;
}
float Magnitude(VECTOR v_normal) {	// возвращает величину вектора
	return sqrt(v_normal.x * v_normal.x + v_normal.y * v_normal.y + v_normal.z * v_normal.z);
}
float Distance(VECTOR point_1, VECTOR point_2) {
	double Distance = sqrt((point_2.x - point_1.x) * (point_2.x - point_1.x) + (point_2.y - point_1.y) * (point_2.y - point_1.y) + (point_2.z - point_1.z) * (point_2.z - point_1.z));
	return (float)Distance;
}
VECTOR Normaliz(VECTOR v) {
	float magnitude = Magnitude(v);
	v = v / magnitude;
	return v;
}
VECTOR CreatVector(VECTOR point_1, VECTOR point_2) {
	VECTOR result;
	result.x = point_1.x - point_2.x;
	result.y = point_1.y - point_2.y;
	result.z = point_1.z - point_2.z;
	// Чтобы получить вектор между 2 точками (направление), нужно вычесть вторую 
	// точку из первой.
	return result;
}
VECTOR Normal(VECTOR triangl[]) {
	// В функцию передаются три вектора — треугольник. Мы получаем vVector1 и vVector2 — его // стороны. Теперь, имея 2 стороны треугольника, мы можем получить из них cross (). 
	// (*ЗАМЕЧАНИЕ*) Важно: первым вектором мы передаём низ треугольника, а вторым — левую 
	// сторону. Если мы поменяем их местами, нормаль будет повернута в противоположную 
	// сторону. В нашем случае мы приняли решение всегда работать против часовой.
	VECTOR v1 = CreatVector(triangl[2], triangl[0]);
	VECTOR v2 = CreatVector(triangl[1], triangl[0]);
	VECTOR normal = Cross(v1, v2);
	// Теперь, имея направление нормали, осталось сделать последнюю вещь. Сейчас её 
	// длинна неизвестна, она может быть очень длинной. Мы сделаем её равной 1, это 
	// называется нормализация.
	normal = Normaliz(normal);
	return normal;
}
VECTOR ClosePointOnLine(VECTOR va, VECTOR vb, VECTOR point) {
	// Создаём вектор от точки vA к точке пространства vPoint.
	VECTOR v1 = point - va;
	// Создаём нормализированный вектор направления от точки vA до vB.
	VECTOR v2 = Normaliz(vb - va);
	// Используем формулу дистанции, чтобы найти величину (magnitude) сегмента линии.
	float d = Distance(va, vb);
	// Используя скалярное произведение, проэцируем vVector1 на vVector2. 
	// Это, по существу, даст нам расстояние от нашего спроецированного вектора до vA.
	float t = Dot(v2, v1);
	// Если наша спроецированная дистанция от vA, "t", меньше или равна нулю, ближайшая
	// точка к vPoint - vA. Возвращаем эту точку.
	if (t <= 0) return va;
	// Если спроецированная дистанция от vA, "t", Больше или равна длинне сегмента линии,
	// ближайшая точка на линии - vB. Вернём её.
	if (t >= d) return vb;
	// Здесь мы создаём вектор с длинной t и направлением vector2.
	VECTOR v3 = v2 * t;
	// Чтобы найти ближайшую точку на отрезке линии, просто прибавляем vVector3 к точке vA.
	VECTOR closes_point = va + v3;
	// Вернём ближайшую точку на линии
	return closes_point;
}
// Возвращает расстояние плоскости от начала координат (0,0,0).
// Принимает нормаль к плоскости и ЛЮБУЮ точку, лежащую на этой плоскости
float PlaneDistance(VECTOR normal, VECTOR point) {
	float distance = 0;	// Переменная хранит дистанцию плоскости от начала координат
	// Используем уравнение плоскости для нахождения дистанции (Ax + By + Cz + D = 0).
	// Нам нужно найти D.
	distance = -(normal.x * point.x + normal.y * point.y + normal.z * point.z);
	return distance;
}
// факт пересечения
bool IntersectedPlane(VECTOR triangle[], VECTOR line[]) {
	float distance_1 = 0; float distance_2 = 0;	// Дистанция от каждой из 2х точек линии до плоскости
	VECTOR normal = Normal(triangle);	// нормаль плоскости
	// Теперь, имея нормаль, нужно получить дистанцию нашего треугольника от начала координат.
	// Начало координат — это точка (0,0,0), так что нам нужно найти самую короткую дистанцию 
	// от плоскости до этой точки. Таким образом мы сможем вычислить пересечения. Очень важно 
	// направление плоскости (мы задаем его нормалью), но так же важно, ГДЕ эта плоскость 
	// находится в 3д мире.
	float originDistance = PlaneDistance(normal, triangle[0]);
	// Нам нужно получить дистанцию КАЖДОЙ из переданных точек линии от нашей плоскости. 
	// Выше мы получили дистанцию плоскости от точки начала 
	// координат, теперь нужна дистанция для каждой точки линии. Если дистанция отрицательная, 
	// точка находится ЗА плоскостью, если положительная — перед. То есть если линия пересекает 
	// плоскость, дистанция будет отрицательной.
	// Теперь нам нужно использовать нечто под названием «формула плоскости» для нахождения 
	// дистанции от каждой точки линии. Вот сама формула: (Ax + By + Cz + D = дистанция)
	// Если дистанция == 0, значит точка НА плоскости.
	// A,B,C — координаты X,Y и Z нормали. x,y,z — координаты любой точки плоскости.
	// A,B,C — координаты X,Y и Z нормали. x,y,z — координаты любой точки плоскости.
	distance_1 = normal.x * line[0].x + normal.y * line[0].y + normal.z * line[0].z + originDistance;
	distance_2 = normal.x * line[1].x + normal.y * line[1].y + normal.z * line[1].z + originDistance;
	// Ок, теперь у нас есть 2 расстояния до плоскости.
	// Если одна дистанция отрицательна а другая 
	// положительна, значит 2 точки находятся по разные стороны плоскости.
	if (distance_1 * distance_2 >= 0) {
		return false;
	}
	else {
		return true;
	}
}
// еще раз алгоритм:
// 1) Для начала нам нужен полигон (хотя бы 3 точки) и линия. 
// Далее находим нормаль полигона.
// 2) Получив нормаль, находим дистанцию плоскости от начала координат. 
// Используем для этого формулу плоскости (Ax + By + Cz + D = 0). 
// Нам нужно найти D, так что чуть переделываем: D = — (Ax + By + Cz)
// 3) Теперь мы можем найти расстояние до обеих точек линии. 
// Используем для этого ту же формулу.
// 4) Умножив дистанции двух точек друг на друга, получим положительное или отрицательное значение. 
// Если оно отрицательное — мы нашли пересечение!
//  необходимо передавать начало и конец линии!
/////////////////////////////////////////////////////////
bool IntersectedPlane(VECTOR poly[], VECTOR line[], VECTOR& normal, float& originDistance) {
	// мы добавим ещё 2 параметра для нормали и дистанции
	// Это делается, чтобы не пересчитывать всё три раза в IntersectionPoint () и IntersectedPolygon ().
	float distance_1 = 0; float distance_2 = 0;
	normal = Normal(poly);
	originDistance = PlaneDistance(normal, poly[0]);	// расстояния от плоскости до (0, 0, 0)
	// дистанция от первой и второй точек
	distance_1 = normal.x * line[0].x + normal.y * line[0].y + normal.z * line[0].z + originDistance;
	distance_2 = normal.x * line[1].x + normal.y * line[1].y + normal.z * line[1].z + originDistance;
	if (distance_1 * distance_2 >= 0) {
		return false;
	}
	else {
		return true;
	}
}
// Следующая функция производит скалярное произведение векторов (я так ищу cos)
float Dot(VECTOR v1, VECTOR v2) {
	return (v1.x * v2.x + v1.y * v2.y + v1.z * v2.z);
}
// Следуюшая функция возвращает угол между векторами
double AngleBetweenVectors(VECTOR v1, VECTOR v2) {
	// Получаем Dot от обоих векторов
	float dot_product = Dot(v1, v2);
	// Получаем умножение величин обоих векторов
	float magnitude = Magnitude(v1) * Magnitude(v2);
	double result = dot_product / magnitude;
	double angle = acos(result);
	return angle;
}
//   Возвращает точку пересечения линии и плоскости
VECTOR IntersectionPoint(VECTOR normal, VECTOR line[], double distance) {
	VECTOR point = { 0, 0, 0 }; VECTOR line_dir = { 0, 0,	0 };
	// Переменные для точки пересечения и направления линии
	double Numerator = 0.0, Denominator = 0.0, dist = 0.0;
	// 1) Сначала нам нужно получить вектор нашей линии, затем нормализовать его
	line_dir = CreatVector(line[1], line[0]); // Получим вектор линии
	line_dir = Normaliz(line_dir);
	// 2) Используем формулу плоскости  чтобы найти дистанцию от одной из 
	// точек до плоскости. Делаем дистанцию отрицательной, т.к. нам нужно идти НАЗАД от нашей точки 
	// к плоскости. Это действие просто возвращает назад к плоскости, чтобы найти точку пересечения.
	Numerator = -(normal.x * line[0].x + normal.y * line[0].y + normal.z * line[0].z);
	// 3) Если мы получим Dot между вектором нашей линии и нормалью полигона, 
	// это даст нам косинус угла между ними (т.к. они обе нормализованы — длинна 1). 
	// Затем мы разделим Numerator на это значение чтобы найти отстояние плоскости от начальной точки.
	Denominator = Dot(normal, line_dir);  // cos
	if (Denominator == 0.0) {
		return line[0];	// линия находится на плоскости
	}
	// Мы делим (дистанция от отчки до плоскости) на (dot product), чтобы получить дистанцию 
	// (dist), которая нужна нам для движения от начальной точки линии. 
	// Нам нужно умножить эту дистанцию (dist) 
	// на вектор линии (line_dir). Когда вы умножаете scalar на ветор, вы двигаетесь вдоль 
	// этого вектора. Это и есть то, что мы делаем. Мы двигаемся от нашей начальной точки, выбранной 
	// на линии, НАЗАД к плоскости вдоль вектора линии. Логично было бы просто получить Numerator, 
	// который является дистанцией от точки до линии, а потом просто двигатся назад вдоль вектора линии. 
	// Дистанция от плоскости — имеется в виду САМАЯ КОРОТКАЯ дистанция. Что если линия почти параллельна 
	// полигону, и не пересекается с ним на протяжении своей длинны? Расстояние до плоскости мало, но 
	// расстояние до точки пересечения вектора линии с плоскостью очень велико. Если мы разделим 
	// дистанцию на dot product из вектора линии и нормали плоскости, то получим правильную длинну.
	dist = Numerator / Denominator;	//	если реальное расстояние до плоскости
	// Теперь, как и говорилось выше, делим дистанцию на вектор, потом добавляем точку линии. 
	// Это переместит точку вдоль вектора на некую дистанцию. Это в свою очередь даст 
	// нам точку пересечения.
	// движение вдоль линии до пересечения
	point.x = (float)(line[0].x + (line_dir.x * dist));
	point.y = (float)(line[0].y + (line_dir.y * dist));
	point.z = (float)(line[0].z + (line_dir.z * dist));
	return point;
}
//   Проверяет, находится ли точка внутри полигона
bool InsidePolygon(VECTOR intersection, VECTOR poly[], long vertice_count) {
	const double MATCH_FACTOR = 0.9999;	// Исп. для покрытия ошибки плавающей точки
	double Angle = 0.0;             // Инициализируем угол
	VECTOR v1, v2;	// временные векторы
	// Одно то, что линия пересекает плоскость, ещё не значит, что она пересекает полигон в
	// этой плоскости. Эта функция проверяет точку пересечения на предмет того, находится ли 
	// она внутри полигона.
	// метод создает треугольники внутри полигона от точки пересечения,
	// проводя линии к каждой вершине полигона. Потом все углы 
	// созданных треугольников складываются. И если сумма углов равна 360, то мы внутри! 
	// Если же значение меньше 360, мы снаружи полигона.
	for (int i = 0; i < vertice_count; i++) {
		// Проходим циклом по каждой вершине и складываем их углы
		v1 = CreatVector(poly[i], intersection); //проводим вектор из вершины к т-ке пересечения
		v2 = CreatVector(poly[(i + 1) % vertice_count], intersection);	//проводим вектор из другой вершины к т-ке пересечения
		// Находим угол между 2мя векторами и складываем их все
		Angle += AngleBetweenVectors(v1, v2);
	}
	// Теперь имея сумму углов, нам нужно проверить, равны ли они 360.
	if (Angle >= (MATCH_FACTOR * (2.0 * PI))) {
		return true;
	}
	else {
		return false;
	}
}
//   Проверяет, пересекается ли линия с полигоном	(тупо функция - объединяшка :) )
bool IntersectedPolygon(VECTOR poly[], VECTOR line[], int vertice_count) {
	VECTOR normal = { 0, 0, 0 }; float originDistance = 0;
	// Сначала проверяем, пересекает ли наша линия плоскость. Если нет — то не нужно
	// продолжать, полигон на плоскости она тоже не пересекает.
	// Передаем в функцию адрес vNormal и originDistance, IntersectedPlane вычислит их для нас.
	if (!IntersectedPlane(poly, line, normal, originDistance)) {
		return false;
	}
	// Чтобы найти точку пересечения, передаем в функцию нормаль плоскости, точки линии и 
	// ближайшую дистанцию до плоскости.
	VECTOR intersection = IntersectionPoint(normal, line, originDistance);
	// Теперь, имея точку пересечения, нужно проверить, лежит ли она внутри полигона.
	if (InsidePolygon(intersection, poly, vertice_count)) {
		return true;
	}
	else {
		return false;
	}
}
// 1) Выяснив, что линия пересекается с плоскостью, нужно получить точку пересечения. 
// Для этого нужно использовать формулу Dot product. 
// Коротко, чтобы найти точку пересечения, нужно найти кратчайшую дистанцию от линии до плоскости, 
// потом двигаться от любой точки линии вдоль вектора линии.
// 2) Найдя точку пересечения, нужно проверить, находится ли эта точка внутри полигона.
/////////////////////////////////////////
// возвращает модуль переданного числа
float Absolute(float num) {
	if (num < 0) {
		return (0 - num);
	}
	else {
		return num;
	}
}
// возвращает true если сфера пересекает переданный полигон.
bool SpherePolygonCollision(VECTOR polygon[], VECTOR& center, int vertex_count, float radius) {
	// что - то вроде функции объединяшки :), но масштабней!
	// шаги:
	// 1) Сначала нужно проверить, пересекается ли сфера с плоскостью, на которой находится 
	// полигон. Для этого написана функция ClassifySphere () которая,
	// возвращает положение сферы относительно плоскости.
	// Если она вернёт INTERSECTS, переходим ко второму шагу.
	// 2) Второй шаг — получить точку пересечения.
	// Поскольку на сфере может распологатся бесконечное
	// число точек, могут быть миллионы точек пересечения.
	// 3) Имея нашу псевдо-точку пересечения, просто передаём её в InsidePolygon (),
	// вместе с вершинами полигона и их числом. Функция вернёт true, если точка
	// пересечения находится внутри полигона. 
	// 4) Если мы дошли досюда, значит, мы нашли точку пересечения, и она находится
	// вне периметра полигона.
	// Последняя проверка нуждается в нахождении точки на каждом ребре полигона, которая
	// ближе всего к центру сферы.
	// Если мы имеем дело с треугольником, нужно пройти три ребра и найти на них 
	// ближайшие точки к центру сферы. После этого рассчитываем дистанцию от этих точек 
	// до центра сферы. Если дистанция меньше, чем радиус, есть пересечение.
	//////////////////////////////////
	VECTOR normal = Normal(polygon);	// нормаль полигона
	float distance = 0.0;
	// Здесь мы определяем, находится ли сфера спереди, сзади плоскости, или пересекает её.
	int classification = ClassifySphere(center, normal, polygon[0], radius, distance);
	// Если сфера пересекает плоскость полигона, нам нужно проверить, пересекает ли 
	// она сам полигон.
	if (classification == INTERSECTS) {
		// Находим псевдо точку пересечения.
		// Теперь нужно спроецировать центр сфера на плоскость полигона, в направлении 
		// его номали. Это делается умножением нормали на расстояние от центра сферы 
		// до плоскости.
		// «я стартую из центра сферы и двигаюсь в направлении плоскости вдоль её нормали 
		// Когда я должен остановится? Тогда, когда моя дистанция от центра сферы станет 
		// равной дистанции от центра сферы до плоскости.»
		VECTOR offset = normal * distance;
		// Получив смещение «offset», просто вычитаем его из центра сферы. «vPosition»
		VECTOR position = center - offset;
		// находится ли точка пересечения внутри полигона
		if (InsidePolygon(position, polygon, vertex_count)) {
			return true; // Есть пересечение
		}
		else {
			// Проверим, пересекает ли сфера рёбра треугольника
			if (EdgeSphereCollision(center, polygon, vertex_count, radius)) {
				return true;
			}
			else {
				return false;
			}
		}
	}
	return false;
}
// вычисляет положение сферы относительно плоскости, а так же расстояние
int ClassifySphere(VECTOR& center, VECTOR& normal, VECTOR& point, float radius, float& distance) {
	// Сначала нужно найти расстояние плоскости от начала координат.
	float d = (float)PlaneDistance(normal, point);
	// расстояние центра сферы от плоскости полигона.
	distance = (normal.x * center.x) + (normal.y * center.y) + (normal.z * center.z) + d;
	// Если расстояние от центра до плоскости меньше, чем радиус 
	// сферы, мы знаем, что пересекли сферу.
	if (Absolute(distance) < radius) return INTERSECTS;	// Если модуль дистанции меньше радиуса, сфера пересекает плоскость.
	else if (distance >= radius) return FRONT;	// Если дистанция больше или равна радиусу, сфера находится перед плоскостью.
	return BEHIND;	// Если и не спереди, и не пересекает — то сзади
}
// определяет, пересекает ли сфера какое - либо ребро треугольника
bool EdgeSphereCollision(VECTOR& center, VECTOR polygon[], int vertex_count, float radius) {
	VECTOR point;
	// Эта ф-я принимает центр сферы, вершины полигона, их чиcло и радиус сферы. Мы вернём 
	// true, если сфера пересекается с каким-либо ребром.
	// Проходим по всем вершинам
	for (int i = 0; i < vertex_count; i++) {
		// Это вернёт ближайшую к центру сферы точку текущего ребра.
		point = ClosePointOnLine(polygon[i], polygon[(i + 1) % vertex_count], center);
		// Теперь нужно вычислить расстояние между ближайшей точкой и центром сферы
		float distance = Distance(point, center);
		// Если расстояние меньше радиуса, должно быть пересечение
		if (distance < radius) return true;
	}
	return false;
}
///////////// (это для коллизии камеры в мире)
// возвращает смещение сферы за плоскость полигона
VECTOR GetCollisionOffset(VECTOR& normal, float radius, float distance) {
	VECTOR Offset = VECTOR(0, 0, 0);
	// Найдя место пересечения, нужно убедится, что сфера не ушла в стену.
	// в программе позиция камеры будет уходить в стену, но мы будет проверять коллизии
	// раньше отрисовки, и смещения не будет заметно визуально.
	// Вопрос в том, как найти направление, в котором нужно «выталкивать» сферу.
	////////////???????????/////////
	// В случае если сфера пересекается с передней стороной полигона, 
	// мы просто вычитаем дистанцию из радиуса, а затем умножаем результат на нормаль плоскости (сдвигаем вдоль нормали).
	// Пояснение (ибо я тупой)
	// Например, скажем у нас есть значения:
	//  vNormal = (1, 0, 0)     radius = 5      distance = 3
	// Если мы вычтем дистанцию из радиуса, то получим (5-3=2)
	// Итак, нам нужно передвинуть сферу назад на 2 единицы. Как же мы узнаем, в каком
	// именно направлении нужно её двигать? Это просто. У нас есть вектор нормали,
	// который сообщает нам направление плоскости.
	// Если мы умножим нормаль на оставшуюся дистанцию, то получим: (2, 0, 0)
	// Этот новый вектор смещения и сообщает нам, в каком направлении и на сколько единиц
	// «выдавливать» сферу. Затем мы вычитаем это смещение из позиции сферы, что даст нам
	// новые координаты, при которых края сферы будут находится точно на плоскости.
	////////////
	// Если же сфера пересекается с другой стороны полигона, мы делаем противоположные расчеты
	// Если дистанция больше ноля, мы спереди полигона
	if (distance > 0) {	// Если дистанция больше ноля, мы спереди полигона
		// Найдем расстояние, на которое сфера углубилась в плоскость, затем
		// найдем вектор направления «выталкивания» сферы
		float distanceOver = radius - distance;
		Offset = normal * distanceOver;
	}
	else {
		// Если же сфера с задней стороны полигона
		// Делаем то же самое, но меняем знаки distance и distanceOver
		float distanceOver = radius + distance;
		Offset = normal * (-distanceOver);
	}
	// Есть одна проблема при проверке пересечений с задней стороной полигона:
	// если вы двигаетесь очень быстро и центр вашей сферы прошел сквозь полигон.
	// программа не выпустит вас обратно, просчитывая пересечения с обратной стороны.
	return Offset;
}